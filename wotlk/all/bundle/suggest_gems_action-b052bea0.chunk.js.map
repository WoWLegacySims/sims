{"version":3,"file":"suggest_gems_action-b052bea0.chunk.js","sources":["../../../../../ui/core/components/suggest_gems_action.ts"],"sourcesContent":["import { IndividualSimUI } from '../individual_sim_ui.js';\nimport { Player } from '../player.js';\nimport { GemColor, ItemSlot, Profession, Spec,Stat } from '../proto/common.js';\nimport { EquippedItem } from '../proto_utils/equipped_item.js';\nimport { Gear } from '../proto_utils/gear.js';\nimport { Stats } from '../proto_utils/stats.js';\nimport { Sim } from '../sim.js';\nimport { TypedEvent } from '../typed_event.js';\n\ninterface GemCapsData {\n\tgemId: number\n\tstatCaps: Stats\n}\n\ninterface SocketData {\n\titemSlot: ItemSlot\n\tsocketIdx: number\n}\n\ninterface SocketBonusData {\n\titemSlot: ItemSlot | null\n\tsocketBonus: number\n}\n\nabstract class GemOptimizer {\n\tprotected readonly player: Player<Spec>;\n\tprotected readonly sim: Sim;\n\tprotected readonly gemPriorityByColor: Record<GemColor, Array<GemCapsData>>;\n\tabstract metaGemID: number;\n\tstatic allGemColors: Array<GemColor> = [GemColor.GemColorRed, GemColor.GemColorYellow, GemColor.GemColorBlue];\n\tepWeights!: Stats;\n\tuseJcGems!: boolean;\n\tisBlacksmithing!: boolean;\n\tcanUseExtraSockets!: boolean;\n\tnumSocketedJcGems!: number;\n\tjcUpgradePriority: Array<GemCapsData>;\n\n\tstatic jcUpgradesById: Record<number, number> = {\n\t\t40118: 42154,\n\t\t40125: 42156,\n\t\t40112: 42143,\n\t\t40111: 42142,\n\t\t40119: 36767,\n\t};\n\n\tconstructor(simUI: IndividualSimUI<any>) {\n\t\tthis.player = simUI.player;\n\t\tthis.sim = simUI.sim;\n\n\t\t// Initialize empty arrays of gem priorities for each socket color\n\t\tthis.gemPriorityByColor = {} as Record<GemColor, Array<GemCapsData>>;\n\n\t\tfor (const gemColor of GemOptimizer.allGemColors) {\n\t\t\tthis.gemPriorityByColor[gemColor] = new Array<GemCapsData>();\n\t\t}\n\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\n\t\tsimUI.addAction('Suggest Gems', 'suggest-gems-action', async () => {\n\t\t\tthis.optimizeGems();\n\t\t});\n\t}\n\n\tasync optimizeGems() {\n\t\t// First, clear all existing gems\n\t\tlet optimizedGear = this.player.getGear().withoutGems();\n\t\tthis.numSocketedJcGems = 0;\n\n\t\t// Store relevant player attributes for use in optimizations\n\t\tthis.epWeights = this.player.getEpWeights();\n\t\tthis.useJcGems = this.player.hasProfession(Profession.Jewelcrafting);\n\t\tthis.isBlacksmithing = this.player.isBlacksmithing();\n\t\tthis.canUseExtraSockets = this.player.canUseExtraSockets()\n\n\t\t/*\n\t\t * Use subclass-specific logic to rank order gems of each color by value\n\t\t * and calculate the associated stat caps for each gem (when applicable).\n\t\t */\n\t\tconst ungemmedStats = await this.updateGear(optimizedGear);\n\t\tthis.updateGemPriority(optimizedGear, ungemmedStats);\n\n\t\t// Next, socket and activate the meta\n\t\toptimizedGear = optimizedGear.withMetaGem(this.sim.db.lookupGem(this.metaGemID));\n\t\toptimizedGear = this.activateMetaGem(optimizedGear);\n\t\tawait this.updateGear(optimizedGear);\n\n\t\t// Now loop through all gem colors where a priority list has been defined\n\t\tfor (const gemColor of GemOptimizer.allGemColors) {\n\t\t\tif (this.gemPriorityByColor[gemColor].length > 0) {\n\t\t\t\toptimizedGear = await this.fillGemsByColor(optimizedGear, gemColor);\n\n\t\t\t\t// Also substitute JC gems by priority while respecting stat caps\n\t\t\t\tif (this.useJcGems) {\n\t\t\t\t\toptimizedGear = await this.substituteJcGems(optimizedGear);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateGear(gear: Gear): Promise<Stats> {\n\t\tthis.player.setGear(TypedEvent.nextEventID(), gear);\n\t\tawait this.sim.updateCharacterStats(TypedEvent.nextEventID());\n\t\treturn Stats.fromProto(this.player.getCurrentStats().finalStats);\n\t}\n\n\t/**\n\t * Helper method for meta gem activation.\n\t *\n\t * @remarks\n\t * Based on the ansatz that most specs are forced to use a suboptimal gem color in\n\t * order to statisfy their meta requirements. As a result, it is helpful to\n\t * compute the item slot in a gear set that provides the strongest socket bonus\n\t * for that color, since this should minimize the \"cost\" of activation.\n\t *\n\t * @param gear - Ungemmed gear set\n\t * @param color - Socket color used for meta gem activation\n\t * @param singleOnly - If true, exclude items containing more than one socket of the specified color. If false, instead normalize the socket bonus by the number of such sockets.\n\t * @param blacklistedColor - If non-null, exclude items containing any sockets of this color (assumed to be different from the color used for activation).\n\t * @returns Optimal item slot for activation under the specified constraints, or null if not found.\n\t */\n\tfindStrongestSocketBonus(gear: Gear, color: GemColor, singleOnly: boolean, blacklistedColor: GemColor | null): SocketBonusData {\n\t\tlet optimalSlot: ItemSlot | null = null;\n\t\tlet maxSocketBonusEP = 1e-8;\n\n\t\tfor (const slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (item.numSocketsOfColor(blacklistedColor) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst numSockets = item.numSocketsOfColor(color);\n\n\t\t\tif ((numSockets == 0) || (singleOnly && (numSockets != 1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst socketBonusEP = new Stats(item.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst normalizedEP = socketBonusEP / numSockets;\n\n\t\t\tif (normalizedEP > maxSocketBonusEP) {\n\t\t\t\toptimalSlot = slot;\n\t\t\t\tmaxSocketBonusEP = normalizedEP;\n\t\t\t}\n\t\t}\n\n\t\treturn { itemSlot: optimalSlot, socketBonus: maxSocketBonusEP };\n\t}\n\n\tsocketGemInFirstMatchingSocket(gear: Gear, itemSlot: ItemSlot | null, colorToMatch: GemColor, gemId: number): Gear {\n\t\tif (itemSlot != null) {\n\t\t\tconst item = gear.getEquippedItem(itemSlot);\n\n\t\t\tif (!item) {\n\t\t\t\treturn gear;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item!.allSocketColors().entries()) {\n\t\t\t\tif (socketColor == colorToMatch) {\n\t\t\t\t\treturn gear.withEquippedItem(itemSlot, item!.withGem(this.sim.db.lookupGem(gemId), socketIdx), true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gear;\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\tconst socketList = this.findSocketsByColor(gear, color);\n\t\treturn await this.fillGemsToCaps(gear, socketList, this.gemPriorityByColor[color], 0, 0);\n\t}\n\n\t/**\n\t * Shared wrapper for compiling eligible sockets for each gem priority list.\n\t *\n\t * @remarks\n\t * Subclasses are required to implement the allowGemInSocket method, which\n\t * contains the (spec-specific) logic on when to match socket bonuses etc.\n\t *\n\t * @param gear - Partially gemmed gear set\n\t * @param color - Color associated with a single gem priority list\n\t * @returns Array of sockets that will be filled using the priority list associated with the specified color.\n\t */\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = new Array<SocketData>();\n\n\t\tfor (const slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item.curSocketColors(this.isBlacksmithing,this.canUseExtraSockets).entries()) {\n\t\t\t\tif (item!.hasSocketedGem(socketIdx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this.allowGemInSocket(color, socketColor, slot, item)) {\n\t\t\t\t\tsocketList.push({ itemSlot: slot, socketIdx: socketIdx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tasync substituteJcGems(gear: Gear): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tlet gemIdx = 0;\n\n\t\twhile ((this.numSocketedJcGems < 3) && (gemIdx < this.jcUpgradePriority.length)) {\n\t\t\tconst gemData = this.jcUpgradePriority[gemIdx];\n\t\t\tconst baseGem = this.sim.db.lookupGem(gemData.gemId);\n\n\t\t\tif (!updatedGear.getAllGems(this.isBlacksmithing,this.canUseExtraSockets).includes(baseGem!)) {\n\t\t\t\tgemIdx += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst upgradedGem = this.sim.db.lookupGem(GemOptimizer.jcUpgradesById[gemData.gemId]);\n\t\t\tconst testGear = updatedGear.withSingleGemSubstitution(baseGem, upgradedGem, this.isBlacksmithing,this.canUseExtraSockets);\n\t\t\tconst newStats = await this.updateGear(testGear);\n\n\t\t\tif (newStats.belowCaps(gemData.statCaps)) {\n\t\t\t\tupdatedGear = testGear;\n\t\t\t\tthis.numSocketedJcGems += 1;\n\t\t\t} else {\n\t\t\t\tawait this.updateGear(updatedGear);\n\t\t\t\tgemIdx += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn updatedGear;\n\t}\n\n\tasync fillGemsToCaps(gear: Gear, socketList: Array<SocketData>, gemCaps: Array<GemCapsData>, numPasses: number, firstIdx: number): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tconst currentGem = this.sim.db.lookupGem(gemCaps[numPasses].gemId);\n\n\t\t// On the first pass, we simply fill all sockets with the highest priority gem\n\t\tif (numPasses == 0) {\n\t\t\tfor (const socketData of socketList.slice(firstIdx)) {\n\t\t\t\tupdatedGear = updatedGear.withGem(socketData.itemSlot, socketData.socketIdx, currentGem);\n\t\t\t}\n\t\t}\n\n\t\t// If we are below the relevant stat cap for the gem we just filled on the last pass, then we are finished.\n\t\tlet newStats = await this.updateGear(updatedGear);\n\t\tconst currentCap = gemCaps[numPasses].statCaps;\n\n\t\tif (newStats.belowCaps(currentCap) || (numPasses == gemCaps.length - 1)) {\n\t\t\treturn updatedGear;\n\t\t}\n\n\t\t// If we exceeded the stat cap, then work backwards through the socket list and replace each gem with the next highest priority option until we are below the cap\n\t\tconst nextGem = this.sim.db.lookupGem(gemCaps[numPasses + 1].gemId);\n\t\tconst nextCap = gemCaps[numPasses + 1].statCaps;\n\t\tlet capForReplacement = currentCap.subtract(nextCap);\n\n\t\tif (currentCap.computeEP(capForReplacement) <= 0) {\n\t\t\tcapForReplacement = currentCap;\n\t\t}\n\n\t\tfor (var idx = socketList.length - 1; idx >= firstIdx; idx--) {\n\t\t\tif (newStats.belowCaps(capForReplacement)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tupdatedGear = updatedGear.withGem(socketList[idx].itemSlot, socketList[idx].socketIdx, nextGem);\n\t\t\tnewStats = await this.updateGear(updatedGear);\n\t\t}\n\n\t\t// Now run a new pass to check whether we've exceeded the next stat cap\n\t\tlet nextIdx = idx + 1;\n\n\t\tif (!newStats.belowCaps(currentCap)) {\n\t\t\tnextIdx = firstIdx;\n\t\t}\n\n\t\treturn await this.fillGemsToCaps(updatedGear, socketList, gemCaps, numPasses + 1, nextIdx);\n\t}\n\n\tabstract activateMetaGem(gear: Gear): Gear;\n\n\tabstract updateGemPriority(ungemmedGear: Gear, passiveStats: Stats): void;\n\n\tabstract allowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean;\n}\n\nexport class PhysicalDPSGemOptimizer extends GemOptimizer {\n\tmetaGemID = 41398; // Relentless Earthsiege Diamond\n\tarpSlop = 11;\n\texpSlop = 4;\n\thitTarget: number = 8. * 32.79;\n\thitSlop = 4;\n\tuseArpGems: boolean;\n\tuseExpGems: boolean;\n\tuseAgiGems: boolean;\n\tuseStrGems: boolean;\n\tarpTarget!: number;\n\tpassiveArp!: number;\n\tarpStackDetected!: boolean;\n\tpassiveHit!: number;\n\ttearSlot!: ItemSlot | null;\n\n\tconstructor(simUI: IndividualSimUI<any>, useArpGems: boolean, useExpGems: boolean, useAgiGems: boolean, useStrGems: boolean) {\n\t\tsuper(simUI);\n\t\tthis.useArpGems = useArpGems;\n\t\tthis.useExpGems = useExpGems;\n\t\tthis.useAgiGems = useAgiGems;\n\t\tthis.useStrGems = useStrGems;\n\t}\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// First calculate any gear-dependent stat caps.\n\t\tthis.arpTarget = this.calcArpTarget(ungemmedGear);\n\t\tconst critCap = this.calcCritCap(ungemmedGear);\n\t\tconst expCap = new Stats().withStat(Stat.StatExpertise, this.calcExpTarget() + this.expSlop);\n\t\tthis.passiveHit = passiveStats.getStat(Stat.StatMeleeHit);\n\t\tconst hitCap = new Stats().withStat(Stat.StatMeleeHit, this.hitTarget + this.hitSlop);\n\n\t\t// Reset optimal Tear slot from prior calculations\n\t\tthis.tearSlot = null;\n\n\t\t/*\n\t\t * For specs that gem ArP, determine whether the current gear\n\t\t * configuration will optimally hard stack Fractured gems or not.\n\t\t */\n\t\tthis.passiveArp = passiveStats.getStat(Stat.StatArmorPenetration);\n\t\tthis.arpStackDetected = this.detectArpStackConfiguration(ungemmedGear);\n\n\t\t/*\n\t\t * Use tighter constraint on overcapping ArP for hard stack setups, so as\n\t\t * to reduce the number of missed yellow socket bonuses.\n\t\t */\n\t\tconst arpSlop = this.arpStackDetected ? 4 : this.arpSlop;\n\t\tconst arpCap = new Stats().withStat(Stat.StatArmorPenetration, this.arpTarget + arpSlop);\n\n\t\t// Update red gem priority\n\t\tconst redGemCaps = new Array<GemCapsData>();\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.useArpGems) {\n\t\t\tredGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Precise Cardinal Ruby\n\t\tif (this.useExpGems) {\n\t\t\tredGemCaps.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\t// Delicate Cardinal Ruby\n\t\tif (this.useAgiGems) {\n\t\t\tredGemCaps.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\t// Bold Cardinal Ruby\n\t\tif (this.useStrGems) {\n\t\t\tredGemCaps.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorRed] = redGemCaps;\n\n\t\t// Update yellow gem priority\n\t\tconst yellowGemCaps = new Array<GemCapsData>();\n\n\t\t// Accurate Ametrine\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Rigid Ametrine\n\t\tyellowGemCaps.push({ gemId: 40125, statCaps: hitCap });\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.arpStackDetected) {\n\t\t\tyellowGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Accurate Ametrine (needed to add twice to catch some edge cases)\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Glinting Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40148, statCaps: hitCap.add(critCap) });\n\t\t}\n\n\t\t// Etched Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40143, statCaps: hitCap });\n\t\t}\n\n\t\t// Deadly Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40147, statCaps: critCap });\n\t\t}\n\n\t\t// Inscribed Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40142, statCaps: critCap });\n\t\t}\n\n\t\t// Fierce Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40146, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorYellow] = yellowGemCaps;\n\n\t\t// Update JC upgrade priority\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\n\t\tif (this.useExpGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\tif (this.useAgiGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\tif (this.useStrGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\t}\n\n\tdetectArpStackConfiguration(ungemmedGear: Gear): boolean {\n\t\tif (!this.useArpGems) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Generate a \"dummy\" list of red sockets in order to determine whether\n\t\t * ignoring yellow socket bonuses to stack more ArP gems will be correct.\n\t\t * Subtract 2 from the length of this list to account for meta gem +\n\t\t * Nightmare Tear.\n\t\t */\n\t\tconst dummyRedSocketList = this.findSocketsByColor(ungemmedGear, GemColor.GemColorRed);\n\t\tconst numRedSockets = dummyRedSocketList.length - 2;\n\t\tlet projectedArp = this.passiveArp + 20 * numRedSockets;\n\n\t\tif (this.useJcGems) {\n\t\t\tprojectedArp += 42;\n\t\t}\n\n\t\treturn (this.arpTarget > 1000) && (projectedArp > 648) && (projectedArp + 20 < this.arpTarget + 4);\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Nightmare Tear for meta activation. Prioritize blue\n\t\t * sockets for it if possible, and fall back to yellow sockets if not.\n\t\t */\n\t\tconst blueSlotCandidate = this.findBlueTearSlot(gear);\n\t\tconst yellowSlotCandidate = this.findYellowTearSlot(gear);\n\n\t\tlet tearColor = GemColor.GemColorBlue;\n\t\tthis.tearSlot = blueSlotCandidate.itemSlot;\n\n\t\tif ((this.tearSlot == null) || (this.arpStackDetected && (yellowSlotCandidate.socketBonus > blueSlotCandidate.socketBonus))) {\n\t\t\ttearColor = GemColor.GemColorYellow;\n\t\t\tthis.tearSlot = yellowSlotCandidate.itemSlot;\n\t\t}\n\n\t\treturn this.socketTear(gear, tearColor);\n\t}\n\n\tsocketTear(gear: Gear, tearColor: GemColor): Gear {\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.tearSlot, tearColor, 49110);\n\t}\n\n\tfindBlueTearSlot(gear: Gear): SocketBonusData {\n\t\t// Eligible Tear slots have only one blue socket max.\n\t\tconst singleOnly = true;\n\n\t\t/*\n\t\t * Additionally, for hard ArP stack configurations, only use blue sockets\n\t\t * for Tear if there are no yellow sockets in that item slot, since hard\n\t\t * ArP stacks ignore yellow socket bonuses in favor of stacking more\n\t\t * Fractured gems.\n\t\t */\n\t\tconst blacklistedColor = this.arpStackDetected ? GemColor.GemColorYellow : null;\n\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorBlue, singleOnly, blacklistedColor);\n\t}\n\n\tfindYellowTearSlot(gear: Gear): SocketBonusData {\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorYellow, false, GemColor.GemColorBlue);\n\t}\n\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\tconst ignoreYellowSockets = ((item!.numSocketsOfColor(GemColor.GemColorBlue) > 0) && (itemSlot != this.tearSlot));\n\t\tlet matchYellowSocket = false;\n\n\t\tif ((socketColor == GemColor.GemColorYellow) && !ignoreYellowSockets) {\n\t\t\tmatchYellowSocket = new Stats(item.item.socketBonus).computeEP(this.epWeights) > 1e-8;\n\t\t}\n\n\t\treturn ((gemColor == GemColor.GemColorYellow) && matchYellowSocket) || ((gemColor == GemColor.GemColorRed) && !matchYellowSocket);\n\t}\n\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = super.findSocketsByColor(gear, color);\n\n\t\tif (this.arpStackDetected && (color == GemColor.GemColorYellow)) {\n\t\t\tthis.sortYellowSockets(gear, socketList);\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tsortYellowSockets(gear: Gear, yellowSocketList: Array<SocketData>) {\n\t\tyellowSocketList.sort((a,b) => {\n\t\t\t// If both yellow sockets belong to the same item, then treat them equally.\n\t\t\tconst slot1 = a.itemSlot;\n\t\t\tconst slot2 = b.itemSlot;\n\n\t\t\tif (slot1 == slot2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// If an item already has a Nightmare Tear socketed, then bump up any yellow sockets in it to highest priority.\n\t\t\tif (slot1 == this.tearSlot) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (slot2 == this.tearSlot) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// For all other cases, sort by the ratio of the socket bonus value divided by the number of yellow sockets required to activate it.\n\t\t\tconst item1 = gear.getEquippedItem(slot1);\n\t\t\tconst bonus1 = new Stats(item1!.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst item2 = gear.getEquippedItem(slot2);\n\t\t\tconst bonus2 = new Stats(item2!.item.socketBonus).computeEP(this.epWeights);\n\t\t\treturn bonus2 / item2!.numSocketsOfColor(GemColor.GemColorYellow) - bonus1 / item1!.numSocketsOfColor(GemColor.GemColorYellow);\n\t\t});\n\t}\n\n\tcalcArpTarget(gear: Gear): number {\n\t\tlet arpTarget = 1399;\n\n\t\t/*\n\t\t * First handle ArP proc trinkets. If more than one of these are equipped\n\t\t * simultaneously, it is assumed that the user is desyncing them via ICD\n\t\t * resets, such that the soft cap is set by the strongest proc.\n\t\t */\n\t\tif (gear.hasTrinket(45931)) {\n\t\t\tarpTarget -= 751; // Mjolnir Runestone\n\t\t} else if (gear.hasTrinket(50198)) {\n\t\t\tarpTarget -= 678; // Needle-Encrusted Scorpion\n\t\t} else if (gear.hasTrinket(40256)) {\n\t\t\tarpTarget -= 612; // Grim Toll\n\t\t}\n\n\t\t// Then check for Executioner enchant\n\t\tconst weapon = gear.getEquippedItem(ItemSlot.ItemSlotMainHand);\n\n\t\tif (weapon?.enchant?.effectId == 3225) {\n\t\t\tarpTarget -= 120;\n\t\t}\n\n\t\treturn arpTarget;\n\t}\n\n\tcalcExpTarget(): number {\n\t\treturn 6.5 * 32.79;\n\t}\n\n\tcalcCritCap(gear: Gear): Stats {\n\t\t/*\n\t\t * Only some specs incorporate Crit soft caps into their gemming logic, so\n\t\t * the parent method here simply returns an empty Stats object (meaning\n\t\t * that Crit cap will just be ignored elsewhere in the code). Custom\n\t\t * spec-specific subclasses can override this as desired.\n\t\t */\n\t\treturn new Stats();\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\t/*\n\t\t * Parent logic substitutes JC gems after filling normal gems first, but\n\t\t * for specs that gem ArP, it is more optimal to pre-fill some Fractured\n\t\t * Dragon's Eyes if doing so gets us closer to the target.\n\t\t */\n\t\tlet updatedGear: Gear = gear;\n\n\t\tif ((color == GemColor.GemColorRed) && this.useArpGems && this.useJcGems) {\n\t\t\tupdatedGear = this.optimizeJcArpGems(updatedGear);\n\t\t}\n\n\t\t// Likewise, if we still have JC gems available after finishing the red gems, then force utilization of JC Hit gems if possible.\n\t\tif ((color == GemColor.GemColorYellow) && this.useJcGems && (this.numSocketedJcGems < 3)) {\n\t\t\tupdatedGear = this.fillJcHitGems(updatedGear);\n\t\t}\n\n\t\treturn await super.fillGemsByColor(updatedGear, color);\n\t}\n\n\tcalcDistanceToArpTarget(numJcArpGems: number, numRedSockets: number): number {\n\t\tconst numNormalArpGems = Math.max(0, Math.min(numRedSockets - 3, Math.floor((this.arpTarget + this.arpSlop - this.passiveArp - 34 * numJcArpGems) / 20)));\n\t\tconst projectedArp = this.passiveArp + 34 * numJcArpGems + 20 * numNormalArpGems;\n\t\treturn Math.abs(projectedArp - this.arpTarget);\n\t}\n\n\toptimizeJcArpGems(gear: Gear): Gear {\n\t\t// First determine how many of the JC gems should be 34 ArP gems\n\t\tconst redSocketList = this.findSocketsByColor(gear, GemColor.GemColorRed);\n\t\tconst numRedSockets = redSocketList.length;\n\t\tlet optimalJcArpGems = [0,1,2,3].reduce((m,x)=> this.calcDistanceToArpTarget(m, numRedSockets)<this.calcDistanceToArpTarget(x, numRedSockets) ? m:x);\n\t\toptimalJcArpGems = Math.min(optimalJcArpGems, numRedSockets);\n\n\t\t// Now socket just those gems, saving other JC substitutions for later\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < optimalJcArpGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(redSocketList[i].itemSlot, redSocketList[i].socketIdx, this.sim.db.lookupGem(42153));\n\t\t}\n\n\t\tthis.numSocketedJcGems = optimalJcArpGems;\n\t\treturn updatedGear;\n\t}\n\n\tfillJcHitGems(gear: Gear): Gear {\n\t\tconst yellowSocketList = this.findSocketsByColor(gear, GemColor.GemColorYellow);\n\t\tconst maxJcHitGems = Math.min(3 - this.numSocketedJcGems, yellowSocketList.length);\n\t\tconst desiredJcHitGems = Math.max(0, Math.floor((this.hitTarget + this.hitSlop - this.passiveHit) / 34));\n\t\tconst numJcHitGems = Math.min(desiredJcHitGems, maxJcHitGems);\n\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < numJcHitGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(yellowSocketList[i].itemSlot, yellowSocketList[i].socketIdx, this.sim.db.lookupGem(42156));\n\t\t}\n\n\t\tthis.numSocketedJcGems += numJcHitGems;\n\t\treturn updatedGear;\n\t}\n}\n\nexport class TankGemOptimizer extends GemOptimizer {\n\tmetaGemID = 41380; // Austere Earthsiege Diamond\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// Base class just stuffs pure Stamina gems everywhere\n\t\tconst blueGemCaps = new Array<GemCapsData>();\n\t\tblueGemCaps.push({ gemId: 40119, statCaps: new Stats() });\n\t\tthis.gemPriorityByColor[GemColor.GemColorBlue] = blueGemCaps;\n\t\tthis.jcUpgradePriority = blueGemCaps;\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Shifting Dreadstone gem for meta activation, in the slot\n\t\t * with the strongest bonus for a single red socket.\n\t\t */\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.findStrongestSocketBonus(gear, GemColor.GemColorRed, true, GemColor.GemColorYellow).itemSlot, GemColor.GemColorRed, 40130);\n\t}\n\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\treturn gemColor == GemColor.GemColorBlue;\n\t}\n}\n"],"names":["_GemOptimizer","constructor","simUI","__publicField","this","player","sim","gemPriorityByColor","gemColor","allGemColors","Array","jcUpgradePriority","addAction","async","optimizeGems","optimizedGear","getGear","withoutGems","numSocketedJcGems","epWeights","getEpWeights","useJcGems","hasProfession","Profession","Jewelcrafting","isBlacksmithing","canUseExtraSockets","ungemmedStats","updateGear","updateGemPriority","withMetaGem","db","lookupGem","metaGemID","activateMetaGem","length","fillGemsByColor","substituteJcGems","gear","setGear","TypedEvent","nextEventID","updateCharacterStats","Stats","fromProto","getCurrentStats","finalStats","findStrongestSocketBonus","color","singleOnly","blacklistedColor","optimalSlot","maxSocketBonusEP","slot","getItemSlots","item","getEquippedItem","numSocketsOfColor","numSockets","normalizedEP","socketBonus","computeEP","itemSlot","socketGemInFirstMatchingSocket","colorToMatch","gemId","socketIdx","socketColor","allSocketColors","entries","withEquippedItem","withGem","socketList","findSocketsByColor","fillGemsToCaps","curSocketColors","hasSocketedGem","allowGemInSocket","push","updatedGear","gemIdx","gemData","baseGem","getAllGems","includes","upgradedGem","jcUpgradesById","testGear","withSingleGemSubstitution","belowCaps","statCaps","gemCaps","numPasses","firstIdx","currentGem","socketData","slice","newStats","currentCap","nextGem","nextCap","capForReplacement","subtract","idx","nextIdx","GemOptimizer","GemColor","GemColorRed","GemColorYellow","GemColorBlue","PhysicalDPSGemOptimizer","useArpGems","useExpGems","useAgiGems","useStrGems","super","ungemmedGear","passiveStats","arpTarget","calcArpTarget","critCap","calcCritCap","expCap","withStat","Stat","StatExpertise","calcExpTarget","expSlop","passiveHit","getStat","StatMeleeHit","hitCap","hitTarget","hitSlop","tearSlot","passiveArp","StatArmorPenetration","arpStackDetected","detectArpStackConfiguration","arpSlop","arpCap","redGemCaps","yellowGemCaps","add","numRedSockets","projectedArp","blueSlotCandidate","findBlueTearSlot","yellowSlotCandidate","findYellowTearSlot","tearColor","socketTear","ignoreYellowSockets","matchYellowSocket","sortYellowSockets","yellowSocketList","sort","a","b","slot1","slot2","item1","bonus1","item2","hasTrinket","weapon","ItemSlot","ItemSlotMainHand","enchant","effectId","optimizeJcArpGems","fillJcHitGems","calcDistanceToArpTarget","numJcArpGems","numNormalArpGems","Math","max","min","floor","abs","redSocketList","optimalJcArpGems","reduce","m","x","i","maxJcHitGems","desiredJcHitGems","numJcHitGems","TankGemOptimizer","arguments","blueGemCaps"],"mappings":"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"}